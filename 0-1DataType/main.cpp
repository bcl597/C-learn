#include<stdio.h>
/*=================相关测试函数声明=================
*/
void PrintArray(int a[],int n)
{
    for (int i = 0; i < n; ++i)
    printf("[%d]=%d\n",i,a[i]);
    printf("\n");
}



/*
=================数据类型=================
序号	类型与描述
1	基本数据类型
它们是算术类型，包括整型（int）、字符型（char）、浮点型（float）和双精度浮点型（double）。
2	枚举类型：
它们也是算术类型，被用来定义在程序中只能赋予其一定的离散整数值的变量。
3	void 类型：
类型说明符 void 表示没有值的数据类型，通常用于函数返回值。
4	派生类型：
包括数组类型、指针类型和结构体类型。
 */


/*
====================变量声明====================
*/
///目前float、double类型用的时IEEE754数据格式 1+8+23、1+11+52
///分别是S（sign）、E(exponent)、F(fraction)部分

int main(void)
{
#if 0  ///变量、常量、数据类型、定义
    ///
    int a=10;
    int b=15;

    ///声明一个int常量 var值为5
    const int var=5;///关键字|数据类型|变量名|值
    ///声明一个指向int常量的指针变量   这里的指针是个变量  从右往左看对应的声明部分
    const int* pa=&var; ///pa指向了常量var   关键字|数据类型|变量名|值
    printf("pa->%d\n",*pa);

    ///能指向变量？
    pa=&b;///pa指向了常变量b
    printf("pa->%d\n",*pa);

    int* const pb=&b;
    //声明了一个常量指针，永远指向了变量b
    printf("pb->%d\n",*pb);

#endif
///========================数组声明========================

#if 0  ///数组初始化

    int ara[2][4]={1,2,3,4,5,6,7,8};
    PrintArray(ara[0],4);
    PrintArray(ara[1],4);

    int arb[2][4]={{1,2,3,4},{5,6,7,8}};
    PrintArray(arb[0],4);
    PrintArray(arb[1],4);

    int arc[3][3]={{1,2,3},{},{4,5,6}};
    PrintArray(arc[0],3);
    PrintArray(arc[1],3);
    PrintArray(arc[2],3);

#endif
///程序的一些存储类
/*    auto  auto 存储类是所有局部变量默认的存储类。 函数开始时被创建，在函数结束时被销毁。
        {
        int mount;
        auto int month;
        }

        register
register 存储类
register 存储类用于定义存储在寄存器中而不是 RAM 中的局部变量。
 这意味着变量的最大尺寸等于寄存器的大小（通常是一个字）
 且不能对它应用一元的 '&' 运算符（因为它没有内存位置）。
 存储在寄存器，所以变量的访问速度更快
 但是它不能直接取地址，因为它不是存储在 RAM 中的。
 在需要频繁访问的变量上使用 register 存储类可以提高程序的运行速度。
        static
static 存储类指示编译器在程序的生命周期内保持局部变量的存在
 而不需要在每次它进入和离开作用域时进行创建和销毁。
 因此，使用 static 修饰局部变量可以在函数调用之间保持局部变量的值。
static 修饰符也可以应用于全局变量。
 当 static 修饰全局变量时，会使变量的作用域限制在声明它的文件内。
全局声明的一个 static 变量或方法可以被任何函数或方法调用
 只要这些方法出现在跟 static 变量或方法同一个文件中。
静态变量在程序中只被初始化一次，即使函数被调用多次，该变量的值也不会重置。
        extern
*/
 #if 1///




#endif



    return 0;
}